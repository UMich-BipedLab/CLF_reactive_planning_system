!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CLFRRTPlanner	clf_rrt.cpp	/^    CLFRRTPlanner::CLFRRTPlanner(FakeMap* map, pose_6dof_t start_pose, pose_6dof_t$/;"	f	class:bipedlab::CLFRRTPlanner
COST_FOR_UNKNOWN	main.cc	29;"	d	file:
COST_FOR_UNKNOWN	main_2019.cc	40;"	d	file:
CassieRRTTree	cassie_rrt_tree.cpp	/^CassieRRTTree::CassieRRTTree(const pose_t& startPose, $/;"	f	class:bipedlab::CassieRRTTree
Dstar	Dstar.cc	/^Dstar::Dstar(int maxSteps, double C1){$/;"	f	class:Dstar
Dstar	Dstar_.cc	/^Dstar::Dstar(int maxSteps, double C1){$/;"	f	class:Dstar
FRONTIER_CLOSE_LIST	wavefront_frontier_detection.cc	/^const int MAP_OPEN_LIST = 1, MAP_CLOSE_LIST = 2, FRONTIER_OPEN_LIST = 3, FRONTIER_CLOSE_LIST = 4;$/;"	v
FRONTIER_OPEN_LIST	wavefront_frontier_detection.cc	/^const int MAP_OPEN_LIST = 1, MAP_CLOSE_LIST = 2, FRONTIER_OPEN_LIST = 3, FRONTIER_CLOSE_LIST = 4;$/;"	v
FakeMap	fake_map.cpp	/^    FakeMap::FakeMap(int map_num, double obstacle_threshold) :$/;"	f	class:bipedlab::FakeMap
LocalChart	local_chart.cpp	/^LocalChart::LocalChart(const pose_t& targetPose, double smallRadius)$/;"	f	class:bipedlab::LocalChart
LyapunovDistance	lyapunov_distance.cpp	/^LyapunovDistance::LyapunovDistance(const pose_t& targetPose,$/;"	f	class:bipedlab::LyapunovDistance
MAP_CLOSE_LIST	wavefront_frontier_detection.cc	/^const int MAP_OPEN_LIST = 1, MAP_CLOSE_LIST = 2, FRONTIER_OPEN_LIST = 3, FRONTIER_CLOSE_LIST = 4;$/;"	v
MAP_OPEN_LIST	wavefront_frontier_detection.cc	/^const int MAP_OPEN_LIST = 1, MAP_CLOSE_LIST = 2, FRONTIER_OPEN_LIST = 3, FRONTIER_CLOSE_LIST = 4;$/;"	v
MAX_STEPS	main.cc	28;"	d	file:
MAX_STEPS	main_2019.cc	39;"	d	file:
MIN_FOUND	wavefront_frontier_detection.cc	/^static int MIN_FOUND = 1; \/\/ how many free neighbors would be considered as a frontier point$/;"	v	file:
MIN_FRONTIER	wavefront_frontier_detection.cc	/^static int MIN_FRONTIER = 1; \/\/ how many free neighbors would be considered as a frontier point$/;"	v	file:
MultivariateGaussian	multivariate_gaussian.cpp	/^MultivariateGaussian::MultivariateGaussian($/;"	f	class:bipedlab::MultivariateGaussian
MultivariateGaussian	multivariate_gaussian.cpp	/^MultivariateGaussian::MultivariateGaussian(size_t dimensions) : $/;"	f	class:bipedlab::MultivariateGaussian
N_S	wavefront_frontier_detection.cc	/^const int N_S = 8;$/;"	v
Node	main.cc	/^            Node(T t, U u) {point.x=t; point.y=u;};$/;"	f	struct:Node
Node	main.cc	/^            Node(T t, U u, int id, int pId) {$/;"	f	struct:Node
Node	main.cc	/^        Node() {}$/;"	f	struct:Node
Node	main.cc	/^        Node(geometry_msgs::Point p) : point(p) {}$/;"	f	struct:Node
Node	main.cc	/^struct Node {$/;"	s	file:
Node	main_2019.cc	/^            Node(T t, U u) {point.x=t; point.y=u;};$/;"	f	struct:Node
Node	main_2019.cc	/^            Node(T t, U u, int id, int pId) {$/;"	f	struct:Node
Node	main_2019.cc	/^        Node() {}$/;"	f	struct:Node
Node	main_2019.cc	/^        Node(geometry_msgs::Point p) : point(p) {}$/;"	f	struct:Node
Node	main_2019.cc	/^struct Node {$/;"	s	file:
OCCUPIED	wavefront_frontier_detection.cc	/^static int OCCUPIED = 0; $/;"	v	file:
OCC_THRESHOLD	wavefront_frontier_detection.cc	/^static double OCC_THRESHOLD = 0.0;$/;"	v	file:
OCC_THRESHOLD_OLD	wavefront_frontier_detection.cc	/^static double OCC_THRESHOLD_OLD = 800;$/;"	v	file:
PORT	main.cc	27;"	d	file:
PORT	main_2019.cc	38;"	d	file:
UNKNOWN	wavefront_frontier_detection.cc	/^static int UNKNOWN = -1;$/;"	v	file:
bipedlab	cassie_rrt_tree.cpp	/^namespace bipedlab$/;"	n	file:
bipedlab	clf_rrt.cpp	/^namespace bipedlab $/;"	n	file:
bipedlab	fake_map.cpp	/^namespace bipedlab {$/;"	n	file:
bipedlab	local_chart.cpp	/^namespace bipedlab$/;"	n	file:
bipedlab	lyapunov_distance.cpp	/^namespace bipedlab$/;"	n	file:
bipedlab	multivariate_gaussian.cpp	/^namespace bipedlab$/;"	n	file:
bipedlab	pose.cpp	/^namespace bipedlab$/;"	n	file:
bipedlab	pose_distribution.cpp	/^namespace bipedlab$/;"	n	file:
bipedlab	standalone_lyapunov_distance.cpp	/^namespace bipedlab$/;"	n	file:
calculateKey	Dstar.cc	/^state Dstar::calculateKey(state u) {$/;"	f	class:Dstar
calculateKey	Dstar_.cc	/^state Dstar::calculateKey(state u) {$/;"	f	class:Dstar
children	main.cc	/^        std::vector<Node> children;$/;"	m	struct:Node	file:
children	main_2019.cc	/^        std::vector<Node> children;$/;"	m	struct:Node	file:
close	Dstar.cc	/^bool Dstar::close(double x, double y) {$/;"	f	class:Dstar
close	Dstar_.cc	/^bool Dstar::close(double x, double y) {$/;"	f	class:Dstar
compound	pose.cpp	/^pose_t pose_t::compound(const pose_t& origin) const$/;"	f	class:bipedlab::pose_t
compound	pose_distribution.cpp	/^pose_distribution_t pose_distribution_t::compound(const pose_distribution_t& origin) const$/;"	f	class:bipedlab::pose_distribution_t
computeDistanceFromPoint	lyapunov_distance.cpp	/^double LyapunovDistance::computeDistanceFromPoint(const Point<float>& point) const$/;"	f	class:bipedlab::LyapunovDistance
computeDistanceFromPose	lyapunov_distance.cpp	/^double LyapunovDistance::computeDistanceFromPose(const pose_t& pose) const$/;"	f	class:bipedlab::LyapunovDistance
computeShortestPath	Dstar.cc	/^int Dstar::computeShortestPath() {$/;"	f	class:Dstar
computeShortestPath	Dstar_.cc	/^int Dstar::computeShortestPath() {$/;"	f	class:Dstar
cost	Dstar.cc	/^double Dstar::cost(state a, state b) {$/;"	f	class:Dstar
cost	Dstar_.cc	/^double Dstar::cost(state a, state b) {$/;"	f	class:Dstar
deleteChildFromParent	cassie_rrt_tree.cpp	/^bool CassieRRTTree::deleteChildFromParent(const cassie_rrt_node_t* childToDelete, cassie_rrt_node_t* parentNode)$/;"	f	class:bipedlab::CassieRRTTree
distance_on_manifold	standalone_lyapunov_distance.cpp	/^double distance_on_manifold(double r, double phi, double kPhi)$/;"	f	namespace:bipedlab
distance_to_manifold	standalone_lyapunov_distance.cpp	/^double distance_to_manifold(double r,$/;"	f	namespace:bipedlab
distribution	multivariate_gaussian.cpp	/^double MultivariateGaussian::distribution(const Eigen::VectorXd& vector) const$/;"	f	class:bipedlab::MultivariateGaussian
draw	Dstar.cc	/^void Dstar::draw() {$/;"	f	class:Dstar
draw	Dstar.cc	/^void Dstar::draw() {}$/;"	f	class:Dstar
draw	Dstar_.cc	/^void Dstar::draw() {$/;"	f	class:Dstar
draw	Dstar_.cc	/^void Dstar::draw() {}$/;"	f	class:Dstar
drawCell	Dstar.cc	/^void Dstar::drawCell(state s, float size) {$/;"	f	class:Dstar
drawCell	Dstar.cc	/^void Dstar::drawCell(state s, float z) {}$/;"	f	class:Dstar
drawCell	Dstar_.cc	/^void Dstar::drawCell(state s, float size) {$/;"	f	class:Dstar
drawCell	Dstar_.cc	/^void Dstar::drawCell(state s, float z) {}$/;"	f	class:Dstar
eightCondist	Dstar.cc	/^double Dstar::eightCondist(state a, state b) {$/;"	f	class:Dstar
eightCondist	Dstar_.cc	/^double Dstar::eightCondist(state a, state b) {$/;"	f	class:Dstar
findNearbyNodesFromPose	cassie_rrt_tree.cpp	/^  CassieRRTTree::findNearbyNodesFromPose(const pose_t& pose, float distanceThreshold, bool isMovingBackward)$/;"	f	class:bipedlab::CassieRRTTree
findNearbyNodesToPose	cassie_rrt_tree.cpp	/^  CassieRRTTree::findNearbyNodesToPose(const pose_t& pose, float distanceThreshold, bool isMovingBackward)$/;"	f	class:bipedlab::CassieRRTTree
findNearestNodeFromPose	cassie_rrt_tree.cpp	/^  CassieRRTTree::findNearestNodeFromPose(const pose_t& pose, double* nonHolonomicDistance, bool isMovingBackward)$/;"	f	class:bipedlab::CassieRRTTree
findNearestNodeToPose	cassie_rrt_tree.cpp	/^  CassieRRTTree::findNearestNodeToPose(const pose_t& pose, double* nonHolonomicDistance, bool isMovingBackward)$/;"	f	class:bipedlab::CassieRRTTree
getG	Dstar.cc	/^double Dstar::getG(state u) {$/;"	f	class:Dstar
getG	Dstar_.cc	/^double Dstar::getG(state u) {$/;"	f	class:Dstar
getPath	Dstar.cc	/^list<state> Dstar::getPath() {$/;"	f	class:Dstar
getPath	Dstar_.cc	/^list<state> Dstar::getPath() {$/;"	f	class:Dstar
getPred	Dstar.cc	/^void Dstar::getPred(state u,list<state> &s) {$/;"	f	class:Dstar
getPred	Dstar_.cc	/^void Dstar::getPred(state u,list<state> &s) {$/;"	f	class:Dstar
getRHS	Dstar.cc	/^double Dstar::getRHS(state u) {$/;"	f	class:Dstar
getRHS	Dstar_.cc	/^double Dstar::getRHS(state u) {$/;"	f	class:Dstar
getSucc	Dstar.cc	/^void Dstar::getSucc(state u,list<state> &s) {$/;"	f	class:Dstar
getSucc	Dstar_.cc	/^void Dstar::getSucc(state u,list<state> &s) {$/;"	f	class:Dstar
get_big_neighbours	wavefront_frontier_detection.cc	/^void get_big_neighbours(int n_array[], int position, int map_width) {$/;"	f
get_column_from_offset	wavefront_frontier_detection.cc	/^int get_column_from_offset(int offset, int width) {$/;"	f
get_neighbours	wavefront_frontier_detection.cc	/^void get_neighbours(int n_array[], int position, int map_width) {$/;"	f
get_row_from_offset	wavefront_frontier_detection.cc	/^int get_row_from_offset(int offset, int width) {$/;"	f
gradient_descent_on_manifold	standalone_lyapunov_distance.cpp	/^double gradient_descent_on_manifold(double r, double phi, double kPhi, double rangeEpsilon)$/;"	f	namespace:bipedlab
heuristic	Dstar.cc	/^double Dstar::heuristic(state a, state b) {$/;"	f	class:Dstar
heuristic	Dstar_.cc	/^double Dstar::heuristic(state a, state b) {$/;"	f	class:Dstar
id	main.cc	/^        int id;$/;"	m	struct:Node	file:
id	main_2019.cc	/^        int id;$/;"	m	struct:Node	file:
init	Dstar.cc	/^void Dstar::init(int sX, int sY, int gX, int gY) {$/;"	f	class:Dstar
init	Dstar_.cc	/^void Dstar::init(double sX, double sY, double gX, double gY) {$/;"	f	class:Dstar
initializeTree	cassie_rrt_tree.cpp	/^void CassieRRTTree::initializeTree(const pose_t& start_pose)$/;"	f	class:bipedlab::CassieRRTTree
insert	Dstar.cc	/^void Dstar::insert(state u) {$/;"	f	class:Dstar
insert	Dstar_.cc	/^void Dstar::insert(state u) {$/;"	f	class:Dstar
insertNode	cassie_rrt_tree.cpp	/^cassie_rrt_node_t* CassieRRTTree::insertNode(const pose_t& new_sample,$/;"	f	class:bipedlab::CassieRRTTree
interpolate_pose	pose.cpp	/^pose_t interpolate_pose(const pose_t& priorPose, const pose_t& currentPose, int64_t desiredPoseTime)$/;"	f	namespace:bipedlab
isValid	Dstar.cc	/^bool Dstar::isValid(state u) {$/;"	f	class:Dstar
isValid	Dstar_.cc	/^bool Dstar::isValid(state u) {$/;"	f	class:Dstar
is_frontier_point	wavefront_frontier_detection.cc	/^bool is_frontier_point(const nav_msgs::OccupancyGrid& map, int point, int map_size, int map_width) {$/;"	f
keyHashCode	Dstar.cc	/^float Dstar::keyHashCode(state u) {$/;"	f	class:Dstar
keyHashCode	Dstar_.cc	/^float Dstar::keyHashCode(state u) {$/;"	f	class:Dstar
lineOfSight	local_chart.cpp	/^line_of_sight_t LocalChart::lineOfSight(const Point<float>& observerPosition) const$/;"	f	class:bipedlab::LocalChart
loadTestMap1_	fake_map.cpp	/^    void FakeMap::loadTestMap1_() {$/;"	f	class:bipedlab::FakeMap
loadTestMap2_	fake_map.cpp	/^    void FakeMap::loadTestMap2_() {$/;"	f	class:bipedlab::FakeMap
loadWaveField_	fake_map.cpp	/^    void FakeMap::loadWaveField_() {$/;"	f	class:bipedlab::FakeMap
logPosterior	multivariate_gaussian.cpp	/^double MultivariateGaussian::logPosterior(const Eigen::VectorXd& vector) const$/;"	f	class:bipedlab::MultivariateGaussian
main	main.cc	/^int main(int argc, char **argv) {$/;"	f
main	main_2019.cc	/^int main(int argc, char **argv) {$/;"	f
main	test_rrt.cpp	/^int main(int argc, char *argv[]) {$/;"	f
makeNewCell	Dstar.cc	/^void Dstar::makeNewCell(state u) {$/;"	f	class:Dstar
makeNewCell	Dstar_.cc	/^void Dstar::makeNewCell(state u) {$/;"	f	class:Dstar
nonholonomic_distance	standalone_lyapunov_distance.cpp	/^double nonholonomic_distance(double r,$/;"	f	namespace:bipedlab
occupied	Dstar.cc	/^bool Dstar::occupied(state u) {$/;"	f	class:Dstar
occupied	Dstar_.cc	/^bool Dstar::occupied(state u) {$/;"	f	class:Dstar
operator !=	pose.cpp	/^bool operator!=(const pose_t& lhs, const pose_t& rhs)$/;"	f	namespace:bipedlab
operator !=	pose_distribution.cpp	/^bool operator!=(const pose_distribution_t& lhs, const pose_distribution_t& rhs)$/;"	f	namespace:bipedlab
operator <<	pose.cpp	/^std::ostream& operator<<(std::ostream& out, const pose_6dof_t& pose)$/;"	f	namespace:bipedlab
operator <<	pose.cpp	/^std::ostream& operator<<(std::ostream& out, const pose_t& pose)$/;"	f	namespace:bipedlab
operator ==	pose.cpp	/^bool operator==(const pose_t& lhs, const pose_t& rhs)$/;"	f	namespace:bipedlab
operator ==	pose_distribution.cpp	/^bool operator==(const pose_distribution_t& lhs, const pose_distribution_t& rhs)$/;"	f	namespace:bipedlab
pack_waypoint_data_t	waypoint_data_t.c	/^void pack_waypoint_data_t(const waypoint_data_t *bus, unsigned char bytes[188])$/;"	f
pack_waypoint_data_t	waypoint_data_t_new.c	/^void pack_waypoint_data_t(const waypoint_data_t *bus, unsigned char bytes[216])$/;"	f
parentId	main.cc	/^        int parentId;$/;"	m	struct:Node	file:
parentId	main_2019.cc	/^        int parentId;$/;"	m	struct:Node	file:
point	main.cc	/^        geometry_msgs::Point point;$/;"	m	struct:Node	file:
point	main_2019.cc	/^        geometry_msgs::Point point;$/;"	m	struct:Node	file:
point2rp	local_chart.cpp	/^reduced_egocentric_polar_coords_t LocalChart::point2rp(const Point<float>& point) const$/;"	f	class:bipedlab::LocalChart
pose2rpd	local_chart.cpp	/^egocentric_polar_coords_t LocalChart::pose2rpd(const pose_t& robotPose) const$/;"	f	class:bipedlab::LocalChart
pose_t	pose.cpp	/^pose_t::pose_t(const pose_distribution_t& distribution)$/;"	f	class:bipedlab::pose_t
prepareForSampling	multivariate_gaussian.cpp	/^void MultivariateGaussian::prepareForSampling(void)$/;"	f	class:bipedlab::MultivariateGaussian
probability	multivariate_gaussian.cpp	/^double MultivariateGaussian::probability(const Eigen::VectorXd& vector) const$/;"	f	class:bipedlab::MultivariateGaussian
remove	Dstar.cc	/^void Dstar::remove(state u) {$/;"	f	class:Dstar
remove	Dstar_.cc	/^void Dstar::remove(state u) {$/;"	f	class:Dstar
replan	Dstar.cc	/^bool Dstar::replan(const std::atomic_bool &cancelled) {$/;"	f	class:Dstar
replan	Dstar_.cc	/^bool Dstar::replan() {$/;"	f	class:Dstar
resolvehelper	main_2019.cc	/^int resolvehelper(const char* hostname, int family, const char* service, sockaddr_storage* pAddr) {$/;"	f
rp2point	local_chart.cpp	/^Point<float> LocalChart::rp2point(const reduced_egocentric_polar_coords_t& coords) const$/;"	f	class:bipedlab::LocalChart
rp2point	local_chart.cpp	/^Point<float> LocalChart::rp2point(double r, double phi) const$/;"	f	class:bipedlab::LocalChart
rpd2pose	local_chart.cpp	/^pose_t LocalChart::rpd2pose(const egocentric_polar_coords_t& coords) const$/;"	f	class:bipedlab::LocalChart
rpd2pose	local_chart.cpp	/^pose_t LocalChart::rpd2pose(double r, double phi, double delta) const$/;"	f	class:bipedlab::LocalChart
rpd2target	local_chart.cpp	/^pose_t LocalChart::rpd2target(const egocentric_polar_coords_t& coords, const pose_t& robotPose) const$/;"	f	class:bipedlab::LocalChart
rpd2target	local_chart.cpp	/^pose_t LocalChart::rpd2target(double r, double phi, double delta, const pose_t& robotPose) const$/;"	f	class:bipedlab::LocalChart
sample	multivariate_gaussian.cpp	/^Eigen::VectorXd MultivariateGaussian::sample(void) const$/;"	f	class:bipedlab::MultivariateGaussian
sampleRandomPose	clf_rrt.cpp	/^    pose_6dof_t CLFRRTPlanner::sampleRandomPose(void)$/;"	f	class:bipedlab::CLFRRTPlanner
sampleRandomPoseWithGoalBiased	clf_rrt.cpp	/^    pose_6dof_t CLFRRTPlanner::sampleRandomPoseWithGoalBiased(void)$/;"	f	class:bipedlab::CLFRRTPlanner
setDistributionStatistics	multivariate_gaussian.cpp	/^void MultivariateGaussian::setDistributionStatistics($/;"	f	class:bipedlab::MultivariateGaussian
setG	Dstar.cc	/^void Dstar::setG(state u, double g) {$/;"	f	class:Dstar
setG	Dstar_.cc	/^void Dstar::setG(state u, double g) {$/;"	f	class:Dstar
setRHS	Dstar.cc	/^double Dstar::setRHS(state u, double rhs) {$/;"	f	class:Dstar
setRHS	Dstar_.cc	/^double Dstar::setRHS(state u, double rhs) {$/;"	f	class:Dstar
smooth_descent_on_manifold	standalone_lyapunov_distance.cpp	/^double smooth_descent_on_manifold(double r, double phi, double kPhi, double rangeEpsilon)$/;"	f	namespace:bipedlab
stabilizeDeltaStar	lyapunov_distance.cpp	/^double LyapunovDistance::stabilizeDeltaStar(const Point<float> point) const$/;"	f	class:bipedlab::LyapunovDistance
stabilizeHeading	lyapunov_distance.cpp	/^double LyapunovDistance::stabilizeHeading(const Point<float> point) const$/;"	f	class:bipedlab::LyapunovDistance
stabilizing_delta_star	standalone_lyapunov_distance.cpp	/^double stabilizing_delta_star(double r,$/;"	f	namespace:bipedlab
transformToNewFrame	pose.cpp	/^pose_t pose_t::transformToNewFrame(const pose_t& newFrame) const$/;"	f	class:bipedlab::pose_t
trueDist	Dstar.cc	/^double Dstar::trueDist(state a, state b) {$/;"	f	class:Dstar
trueDist	Dstar_.cc	/^double Dstar::trueDist(state a, state b) {$/;"	f	class:Dstar
unpack_waypoint_data_t	waypoint_data_t.c	/^void unpack_waypoint_data_t(const unsigned char bytes[188], waypoint_data_t *bus)$/;"	f
unpack_waypoint_data_t	waypoint_data_t_new.c	/^void unpack_waypoint_data_t(const unsigned char bytes[216], waypoint_data_t *bus)$/;"	f
updateCell	Dstar.cc	/^void Dstar::updateCell(int x, int y, double val) {$/;"	f	class:Dstar
updateCell	Dstar_.cc	/^void Dstar::updateCell(double x, double y, double val) {$/;"	f	class:Dstar
updateGoal	Dstar.cc	/^void Dstar::updateGoal(int x, int y) {$/;"	f	class:Dstar
updateGoal	Dstar_.cc	/^void Dstar::updateGoal(double x, double y) {$/;"	f	class:Dstar
updateStart	Dstar.cc	/^void Dstar::updateStart(int x, int y) {$/;"	f	class:Dstar
updateStart	Dstar_.cc	/^void Dstar::updateStart(double x, double y) {$/;"	f	class:Dstar
updateVertex	Dstar.cc	/^void Dstar::updateVertex(state u) {$/;"	f	class:Dstar
updateVertex	Dstar_.cc	/^void Dstar::updateVertex(state u) {$/;"	f	class:Dstar
wfd	wavefront_frontier_detection.cc	/^vector<vector<int> > wfd(const nav_msgs::OccupancyGrid& map, $/;"	f
~CLFRRTPlanner	clf_rrt.cpp	/^    CLFRRTPlanner::~CLFRRTPlanner() { }$/;"	f	class:bipedlab::CLFRRTPlanner
~FakeMap	fake_map.cpp	/^    FakeMap::~FakeMap() {}$/;"	f	class:bipedlab::FakeMap
